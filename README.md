# LW3D
## Code Overview

This version of the Lienard-Wiechert code, LW3D, computes the LW field due to a large number of electrons transiting a beamline, without approximation, at a set of observation points. This version is a t-code. It integrates (x,gbx,y,gby,z,gbz) as a function of time, where gbx=gamma*beta_x, etc. It prints the LW field at the end of timesteps chosen by the user on a grid of observation points chosen by the user. This version is not self-consistent; the electrons travel on trajectories determined by the external field. Hence the main use of this version of the code is to explore the full (near-field and far-field, Coulomb-like and radiative) 3D fields generated by an electron bunch propagating in a beamline neglecting the action of the self-field on the particle dynamics.

## Code Organization  
aamain.f90 : the main program  
probcons.f90 : contains many problem parameters  
lienwiech.f90 : the guts of the code; it computes the LW fields  
integrators.f90 : contains the numerical integration routines for advancing particles in time  
evalroutines.f90 : evaluates the RHS of the equations of motion. Contains subroutine getexternalfield().  
distribution.f90 : sets the initial distribution of particles  
random.f90 : random number routines  
diagnostics.f90 : diagnostic routines, e.g., to write 2nd moments  
putils.f90 : parallel utility routines, e.g., to write the numerical distribution  

## Building the code  
At present there is no makefile. Instead there is a script called "compileit"

## Modifying the code for your problem  
This version of the code does not have an input file. To model a specific problem a user needs to edit the code. There are 2 places where a user will need to make changes:

probcons.f90 contains many problem parameters.  
evalroutines.f90 contains subroutine getexternalfield(). This routine returns the external field at a point (t,x,y,z).  

## Details of subroutine getexternalfield()  
evalroutines.f90 contains subroutine getexternalfield(). This routine returns the external field at a point (t,x,y,z). The beamline geometry (location of magnets, etc.) is described in a global Cartesian frame. Note that the fields must be smooth (no hard edges). At present this routine describes an undulator comprised of alternating soft-edge dipole magnets with midplane symmetry. The magnetic field is prescribed in the midplane and off-axis contributions are included as expansions that satisfy Maxwell's equations.

## Specifying the LW field output grid  
The output grid is controlled by several parameters in probcons.f90 . For example,  
      integer, parameter :: imax=10     !size of the x output grid  
      integer, parameter :: jmax=3      !size of the y output grid  
      integer, parameter :: kmax=10000  !size of the z output grid  
      real*8, parameter :: xoffmin=-1.d-3     !xmin/max grid range  
      real*8, parameter :: xoffmax= 1.d-3    
      real*8, parameter :: yoffmin=-1.d-3     !ymin/max grid range  
      real*8, parameter :: yoffmax= 1.d-3  
      real*8, parameter :: zoffmin=5.0d-4     !zmin/max grid range  
      real*8, parameter :: zoffmax=1.0d-4  
      integer :: irotategrid=0 !(0 or 1) controls if grid is aligned w/ direction of motion  
      real*8 :: relativetocentroid=1.d0 !(0 or 1) grid sizes are absolute or relative to centroid

The parameters imax,jmax,kmax are the x-y-z grid dimensions. The offset parameters x/y/zoff/min/max describe the physical grid size. If relativetocentroid=1.d0 the parameters are interpreted as offsets relative to the centroid. If relativetocentroid=0.d0 they describe the grid in the global Cartesian system (i.e., the system also used in subroutine getexternalfield). If irotategrid=0 the grid output grid is aligned with the global system. If irotategrid=1 the output grid is centered on the bunch centroid and rotated so that the z-axis is along the direction of motion.


## Specifying when the code will compute the LW fields  
File probcons.f90 contains subroutine testtoperformfieldcalc(cent,nstep,idofieldcalc) that is called to determine when to compute the LW fields. For example,  
      if(cent(5).gt.50.4d0)idofieldcalc=1  
tells the code to compute the fields when the centroid has exceeded 50.4 meters. As another example,  
      if(mod(nstep,100).eq.0)idofieldcalc=1  
tells the code to compute the fields every 100 steps.

File probcons.f90 also contains the parameter istopafter1fieldcalc. The user should set istopafter1fieldcalc=1 to stop after the code first computes the LW fields. The user should set istopafter1fieldcalc=0 for multiple outputs as would be the case, for example, when computing the fields every 100 steps.


## Output Files  
fieldNNNN: the LW field at the end of timestep NNNN. Columns are:  
Columns 1-3:   xobs yobs zobs (observation point)  
Columns 4-9:   exvel eyvel ezvel exrad eyrad ezrad (LW electric field)  
Columns 10-15: bxvel byvel bzvel bxrad byrad bzrad (LW magnetic field)  
Columns 16-18: poyntxrad poyntyrad poyntzrad (Poynting vector)  
Columns 19-20: i k (grid indices)  
Columns 21-22: x_rel z_rel (x and z relative to centroid)

The file fieldNNNN is opened in lienwiech.f90 by the statement:  
call openfile(fname,300,nsuffix,4)  
The last argument is the number of digits in the file name. If you use more than 9999 steps you should change it to something larger (e.g. change 4 to 5 for 10k to 99999 steps).

xrms.out ,yrms.out ,zrms.out : rms output in a frame of reference aligned with the direction of motion of the centroid (accomplished by rotation through an angle theta).  
For example, columns of xrms.out are:  
t, xrms, pxrms, xpxrms, emitxrms, xcentroid, pxcentroid, Ngood, theta

amom.out : a more complicated file of 2nd moments. See "write(nfile0..." in subroutine moments in file diagnostics.f90

refhist.out: the history of 1 particle (which happens to be particle #1 on MPI process 0).  
The columns are  
t, x, gbx, y, gby, z, gbz

initp.out: a sample of particles from the initial distribution  
finalp.out: a sample of particles from the final distribution

## Specifying parameters of the initial distribution  
See subroutine getmatrixandcentroid(ekin,cent,sigmat) in file probcons.f90 .  
Note, in particular, that cent(5) is the initial z centroid. You need to make sure that this is consistent with the geometrical layout of the magnets specified in subroutine getexternalfield(). For example, if the fringe field of the first magnet is centered at z=0, then you want cent(5) to equal some number (e.g. cent(5)=-0.20 meters) that is before the fringe field. On the other hand if the first magnet is centered at 0.2 meters then it is fine to set cent(5)=0 (assuming the fringe region is sufficiently narrow).

## Details on modifying subroutine getexternalfield() in evalroutines.f90  
Subroutine getexternalfield contains all the information describing where the magnets are located, their strengths, etc. At the moment it is hardwired to model an undulator comprised of alternating soft-edge dipole magnets. It uses a tanh model for the dipole fringe fields. Be sure to make your timestep small enough to resolve the fringe fields.

## Note on subroutine getexternalfield()  
This is called in 3 places: subroutine eval(), subroutine evalt1(), and subroutine lwfieldcalc().

## Comments on the iterative search to find retarded times  
The file lienwiech.f90 contains the routines that find the retarded times and compute the LW fields. Note that, if the time between adjacent history values is too large, the search algorithm might have trouble finding the retarded time. On the other hand if nsteps is too large (so the history values are closer together in time), then the code will run out of memory. It is possible to reduce the memory if you know the minimum value of the retarded time for your problem.

## Comments on tauini,taufin, nsteps,tauhistmin,tauhistmax  
The code integrates trajectories in time from tauini to taufin using Adams11. The number of steps is called nsteps. After each step the code decides if it should or should not store a trajectory value in the history arrays. If the time at the end of a step is between tauhistmin and tauhistmax then it will store it. Note well: If a retarded time precedes the minimum time in the history, the code will return zero field and not write any error message.    

## Comments on diagnostic output  
This version of the code produces a lot of diagnostic output to help understand if it is working properly. Every time there is a LW calculation (at the end of some timestep), the code writes quantities such as the minimum and maximum retarded time. This can be used to adjust tauhistmin and thereby save memory. The code also writes the maximum value of the light cone condition, which should be zero but is normally some tiny number.

## Comments on memory usage  
This version of the code uses very large memory. There are two reasons for this: (1) the code stores a portion of the time history of every particle, and (2) the grid of observation points is replicated on all MPI processes. The user needs to be aware of this issue because it is easy to run out of memory. There are things the user can do to reduce the memory, as described above.
